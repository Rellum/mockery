package mockery

import (
	"bufio"
	"go/format"
	"path/filepath"
	"strings"
	"testing"

	"github.com/sebdah/goldie/v2"
	"github.com/stretchr/testify/require"
	"github.com/stretchr/testify/suite"
)

//go:generate go test github.com/vektra/mockery/mockery -run TestGeneratorSuite -update

const pkg = "test"

type GeneratorSuite struct {
	suite.Suite
	parser *Parser
	goldie goldie.Tester
}

func (s *GeneratorSuite) SetupSuite() {
	s.goldie = goldie.New(s.T())
}

func (s *GeneratorSuite) SetupTest() {
	s.parser = NewParser(nil)
}

func (s *GeneratorSuite) getInterfaceFromFile(interfacePath, interfaceName string) *Interface {
	if !strings.Contains(interfacePath, fixturePath) {
		interfacePath = filepath.Join(fixturePath, interfacePath)
	}
	s.NoError(
		s.parser.Parse(interfacePath), "The parser is able to parse the given file.",
	)

	s.NoError(
		s.parser.Load(), "The parser is able to load the config.",
	)

	iface, err := s.parser.Find(interfaceName)
	s.Require().NoError(err)
	s.Require().NotNil(iface)
	return iface
}

func (s *GeneratorSuite) getGenerator(
	filepath, interfaceName string, inPackage bool,
) *Generator {
	return NewGenerator(s.getInterfaceFromFile(filepath, interfaceName), pkg, inPackage)
}

func (s *GeneratorSuite) checkGeneration(filepath, interfaceName string,
	inPackage bool) *Generator {

	generator := s.getGenerator(filepath, interfaceName, inPackage)
	s.NoError(generator.Generate(), "The generator ran without errors.")

	// Mirror the formatting done by normally done by golang.org/x/tools/imports in Generator.Write.
	//
	// While we could possibly reuse Generator.Write here in addition to Generator.Generate,
	// it would require changing Write's signature to accept custom options, specifically to
	// allow the fragments in preexisting cases. It's assumed that this approximation,
	// just formatting the source, is sufficient for the needs of the current test styles.
	var actual []byte
	actual, fmtErr := format.Source(generator.buf.Bytes())
	s.NoError(fmtErr, "The formatter ran without errors.")

	s.goldie.Assert(s.T(), s.T().Name(), actual)

	return generator
}

func (s *GeneratorSuite) checkPrologueGeneration(generator *Generator) {
	generator.GeneratePrologue("mocks")
	s.goldie.Assert(s.T(), s.T().Name(), generator.buf.Bytes())
}

func (s *GeneratorSuite) TestCalculateImport() {
	gp := []string{"a/src", "b/src"}

	s.Equal("c", calculateImport(gp, "a/src/c"))
	s.Equal("c", calculateImport(gp, "b/src/c"))
	s.Equal("d/src/c", calculateImport(gp, "d/src/c"))
}

func (s *GeneratorSuite) TestGenerator() {
	s.checkGeneration(testFile, "Requester", false)
}

func (s *GeneratorSuite) TestGeneratorSingleReturn() {
	s.checkGeneration(testFile2, "Requester2", false)
}

func (s *GeneratorSuite) TestGeneratorNoArguments() {
	s.checkGeneration(filepath.Join(fixturePath, "requester3.go"), "Requester3", false)
}

func (s *GeneratorSuite) TestGeneratorNoNothing() {
	s.checkGeneration(filepath.Join(fixturePath, "requester4.go"), "Requester4", false)
}

func (s *GeneratorSuite) TestGeneratorUnexported() {
	s.checkGeneration("requester_unexported.go", "requester_unexported", true)
}

func (s *GeneratorSuite) TestGeneratorPrologue() {
	generator := s.getGenerator(testFile, "Requester", false)
	s.checkPrologueGeneration(generator)
}

func (s *GeneratorSuite) TestGeneratorPrologueWithImports() {
	generator := s.getGenerator("requester_ns.go", "RequesterNS", false)
	s.checkPrologueGeneration(generator)
}

func (s *GeneratorSuite) TestGeneratorPrologueWithMultipleImportsSameName() {
	generator := s.getGenerator("same_name_imports.go", "Example", false)

	s.checkPrologueGeneration(generator)
}

func (s *GeneratorSuite) TestGeneratorPrologueNote() {
	generator := s.getGenerator(testFile, "Requester", false)
	generator.GeneratePrologueNote("A\\nB")

	s.goldie.Assert(s.T(), s.T().Name(), generator.buf.Bytes())
}

func (s *GeneratorSuite) TestVersionOnCorrectLine() {
	gen := s.getGenerator(testFile, "Requester", false)

	//Run everything that is ran by the GeneratorVisitor
	gen.GeneratePrologueNote("A\\nB")
	gen.GeneratePrologue(pkg)
	err := gen.Generate()

	require.NoError(s.T(), err)
	scan := bufio.NewScanner(&gen.buf)
	s.Contains("Code generated by", scan.Text())
}

func (s *GeneratorSuite) TestGeneratorChecksInterfacesForNilable() {
	s.checkGeneration(filepath.Join(fixturePath, "requester_iface.go"), "RequesterIface", false)
}

func (s *GeneratorSuite) TestGeneratorPointers() {
	s.checkGeneration(filepath.Join(fixturePath, "requester_ptr.go"), "RequesterPtr", false)
}

func (s *GeneratorSuite) TestGeneratorSlice() {
	s.checkGeneration(filepath.Join(fixturePath, "requester_slice.go"), "RequesterSlice", false)
}

func (s *GeneratorSuite) TestGeneratorArrayLiteralLen() {
	s.checkGeneration(filepath.Join(fixturePath, "requester_array.go"), "RequesterArray", false)
}

func (s *GeneratorSuite) TestGeneratorNamespacedTypes() {
	s.checkGeneration(filepath.Join(fixturePath, "requester_ns.go"), "RequesterNS", false)
}

func (s *GeneratorSuite) TestGeneratorWhereArgumentNameConflictsWithImport() {
	s.checkGeneration(filepath.Join(fixturePath, "requester_arg_same_as_import.go"), "RequesterArgSameAsImport", false)
}

func (s *GeneratorSuite) TestGeneratorWhereArgumentNameConflictsWithNamedImport() {
	s.checkGeneration(filepath.Join(fixturePath, "requester_arg_same_as_named_import.go"), "RequesterArgSameAsNamedImport", false)
}

func (s *GeneratorSuite) TestGeneratorWhereArgumentNameConflictsWithPackage() {
	s.checkGeneration(filepath.Join(fixturePath, "requester_arg_same_as_pkg.go"), "RequesterArgSameAsPkg", false)
}

func (s *GeneratorSuite) TestGeneratorHavingNoNamesOnArguments() {
	s.checkGeneration(filepath.Join(fixturePath, "custom_error.go"), "KeyManager", false)
}

func (s *GeneratorSuite) TestGeneratorElidedType() {
	s.checkGeneration(filepath.Join(fixturePath, "requester_elided.go"), "RequesterElided", false)
}

func (s *GeneratorSuite) TestGeneratorReturnElidedType() {
	s.checkGeneration(filepath.Join(fixturePath, "requester_ret_elided.go"), "RequesterReturnElided", false)
}

func (s *GeneratorSuite) TestGeneratorVariadicArgs() {
	s.checkGeneration(filepath.Join(fixturePath, "requester_variadic.go"), "RequesterVariadic", false)
}

func (s *GeneratorSuite) TestGeneratorFuncType() {
	s.checkGeneration(filepath.Join(fixturePath, "func_type.go"), "Fooer", false)
}

func (s *GeneratorSuite) TestGeneratorChanType() {
	s.checkGeneration(filepath.Join(fixturePath, "async.go"), "AsyncProducer", false)
}

func (s *GeneratorSuite) TestGeneratorFromImport() {
	s.checkGeneration(filepath.Join(fixturePath, "io_import.go"), "MyReader", false)
}

func (s *GeneratorSuite) TestGeneratorComplexChanFromConsul() {
	s.checkGeneration(filepath.Join(fixturePath, "consul.go"), "ConsulLock", false)
}

func (s *GeneratorSuite) TestGeneratorForEmptyInterface() {
	s.checkGeneration(filepath.Join(fixturePath, "empty_interface.go"), "Blank", false)
}

func (s *GeneratorSuite) TestGeneratorForMapFunc() {
	s.checkGeneration(filepath.Join(fixturePath, "map_func.go"), "MapFunc", false)
}

func (s *GeneratorSuite) TestGeneratorForMethodUsingInterface() {
	s.checkGeneration(filepath.Join(fixturePath, "mock_method_uses_pkg_iface.go"), "UsesOtherPkgIface", false)
}

func (s *GeneratorSuite) TestGeneratorForMethodUsingInterfaceInPackage() {
	s.checkGeneration(filepath.Join(fixturePath, "mock_method_uses_pkg_iface.go"), "UsesOtherPkgIface", true)
}

func (s *GeneratorSuite) TestGeneratorWithAliasing() {
	s.checkGeneration(filepath.Join(fixturePath, "same_name_imports.go"), "Example", false)
}

func (s *GeneratorSuite) TestGeneratorWithImportSameAsLocalPackageInpkgNoCycle() {
	iface := s.getInterfaceFromFile("imports_same_as_package.go", "ImportsSameAsPackage")
	pkg := iface.QualifiedName
	gen := NewGenerator(iface, pkg, true)
	gen.GeneratePrologue(pkg)
	s.NotContains(gen.buf.String(), `import test "github.com/vektra/mockery/mockery/fixtures/test"`)
}

func (s *GeneratorSuite) TestGeneratorWithImportSameAsLocalPackage() {
	s.checkGeneration("imports_same_as_package.go", "ImportsSameAsPackage", false)
}

func (s *GeneratorSuite) TestPrologueWithImportSameAsLocalPackage() {
	generator := s.getGenerator(
		"imports_same_as_package.go", "ImportsSameAsPackage", false,
	)
	s.checkPrologueGeneration(generator)
}

func (s *GeneratorSuite) TestPrologueWithImportFromNestedInterface() {
	generator := s.getGenerator(
		"imports_from_nested_interface.go", "HasConflictingNestedImports", false,
	)

	s.checkPrologueGeneration(generator)
}

func (s *GeneratorSuite) TestGeneratorForStructValueReturn() {
	s.checkGeneration(filepath.Join(fixturePath, "struct_value.go"), "A", false)
}

func TestGeneratorSuite(t *testing.T) {
	generatorSuite := new(GeneratorSuite)
	suite.Run(t, generatorSuite)
}
